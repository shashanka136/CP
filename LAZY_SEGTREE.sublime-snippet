<snippet>
	<content><![CDATA[
struct item_lazy {
    ll n;
    item_lazy(ll x = 0): n(x) {}

    item_lazy operator*(const item_lazy& oth) { //operation to merge
        item_lazy r;//default is done for sum
        r.n = n + oth.n;//must be a associative function
        return r;
    }
    bool operator==(item_lazy oth) {
        return n == oth.n;
    }
};

struct item {
    ll n;
    item(ll x = 0): n(x) {}
    item operator+(const item& oth) { //operation to merge
        item r;//default is done for sum
        r.n = n + oth.n;
        return r;
    }
    item operator*(const item_lazy& oth) { //operation to merge
        item r;
        r.n = n + oth.n;//must be a associative function
        return r;
    }
};
ll a;
template<class node, class node1>
struct segtree {
    int n;
    vector<node> st;
    vector<node1> lazy;
    void init(int _n) { //give some default value value if required
        n = 1;
        while (n < _n) n *= 2;
        st.assign(2 * n, node());
        lazy.assign(2*n, node1());//initialize with different value if required
    }
    inline int le(int x) {
        return 2 * x + 1;
    }
    inline int ri(int x) {
        return 2 * x + 2;
    }

    void build(vector<int> &a, int l, int r, int p) {
        if (l == r) {
            if (l < int(a.size())) st[p] = a[l];
            return;
        }
        int m = l + r >> 1;
        build(a, l, m, le(p));
        build(a, m + 1, r, ri(p));
        st[p] = st[le(p)] + st[ri(p)];
    }

    void build(vector<int> &a) {
        init(a.size());
        build(a, 0, n - 1, 0);
    }

    void build(int _n, int l, int r, int p) {
        if (l == r) {
            if (l < _n) {
                cin>>a;
                st[p] = a;
            }
            return;
        }
        int m = l + r >> 1;
        build(_n, l, m, le(p));
        build(_n, m + 1, r, ri(p));
        st[p] = st[le(p)] + st[ri(p)];
    }

    void build(int _n) {
        init(_n);
        build(_n,0, n - 1, 0);
    }

    void push(node1 &x, int l, int r, int p) {
        if(!(x == node1())) {
            st[p] = st[p] * x;
            if(l != r) {
                lazy[le(p)] = lazy[le(p)] * x;
                lazy[ri(p)] = lazy[ri(p)] * x;
            }
            x = node1();
        }
    }
    void set(int i, ll x, int l, int r, int p) {
        push(lazy[p],l,r,p);
        if (i < l || i > r) return;
        if (l == r) {
            st[p] = x;
            return;
        }
        int m = l + r >> 1;
        if (i <= m) set(i, x, l, m, le(p));
        else set(i, x, m + 1, r, ri(p));

        st[p] = st[le(p)] + st[ri(p)];
    }
    void set(int i, ll x) {
        set(i, x, 0, n - 1, 0);
    }
    void set(int ql, int qr, ll x, int l, int r, int p) {
        push(lazy[p],l,r,p);
        if (qr < l || ql > r) return;
        if (l == r) {
            st[p] = x;
            return;
        }
        int m = l + r >> 1;
        set(ql, qr, x, l, m, le(p));
        set(ql, qr, x, m + 1, r, ri(p));

        st[p] = st[le(p)] + st[ri(p)];
    }
    void set(int l, int r, ll x) {
        set(l, r, x, 0, n - 1, 0);
    }

    void add(int ql, int qr, ll x, int l, int r, int p) {
        push(lazy[p],l,r,p);
        if (qr < l || ql > r) return;
        if (ql <=l && r <= qr) {
            lazy[p] = x;
            push(lazy[p],l,r,p);
            return;
        }
        int m = l + r >> 1;
        add(ql, qr, x, l, m, le(p));
        add(ql, qr, x, m + 1, r, ri(p));
        st[p] = st[le(p)] + st[ri(p)];
    }
    void add(int l, int r, ll x) {
        add(l,r,x,0,n-1,0);
    }

    node get(int i, int l, int r, int p) {
        // cout<<"query"<<endl;
        push(lazy[p],l,r,p);
        if (l == r) return st[p];
        int m = l + r >> 1;
        if(i <= m)  return get(i, l, m, le(p));
        else return get(i, m + 1, r, ri(p));
    }

    node get(int i) {
        return get(i,0,n-1,0);
    }

    node query(int ql, int qr, int l, int r, int p) {
        // cout<<"query"<<endl;
        push(lazy[p],l,r,p);
        if (r < ql || l > qr) return node();
        if (ql <= l && r <= qr) return st[p];
        int m = l + r >> 1;
        return query(ql, qr, l, m, le(p)) +
               query(ql, qr, m + 1, r, ri(p));
    }

    node query(int l, int r) {
        return query(l, r, 0, n - 1, 0);
    }
};
typedef segtree<item, item_lazy> segm;

]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>_lazy--</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
