<snippet>
	<content><![CDATA[
#define SZ 666666
ll roots[2][SZ];
inline ll powm(ll a,ll b, ll mod=mod){
    ll ans=1;
    while(b){
        if(b&1) ans=ans*a%mod;
        a=a*a%mod; 
        b>>=1;
    }
    return ans;
}
int nx2;
inline void fftinit(int n){//for mod = 9982444353, mod-1 = 119 * (2^23)
    nx2 = 1;
    while(nx2 < n) nx2 <<=1;
    roots[0][0]=roots[0][nx2]=1;
    ll gen=powm(3,(mod-1)/nx2);// it is assumed that mod-1 is divisible by nx2 and mod-1 is prime
    // 3 is a generator of Z*_mod
    // gen represents nx2th root of unity, gen^nx2 = 3^(mod-1) = 1(mod mod) and rest all are not 1
    // roots represent nx2th root of unity
    for(int i=1;i<nx2;i++){
        roots[0][i]=roots[0][i-1]*gen%mod;//for fft
    }
    for(int i=0;i<=nx2;i++){
        roots[1][i]=roots[0][nx2-i]; //for inverse fft
    }
}
inline void fft(int* x,int inv){// if inv is 1 then we have to do inverse fft, else fft
    for(int i=0;i<nx2;i++){//ensure that all 
        x[i]=(x[i]%mod+mod)%mod;
    }
    for(int i=0,j=0;i<nx2;i++){//bit inverse permutation
        if(i>j) swap(x[i],x[j]);
        for(int bit=nx2>>1; (j^=bit)<bit; bit>>=1);// adding 1 to i and nx2>>1 to j(inverse of i) in reverse sense
    }
    for(int len=2;len<=nx2;len<<=1){//forming fft of length len
        for(int k=0;k<(len>>1);k++){//W is (len)th root of unity raise to the power k
            register int W=roots[inv][nx2/len*k],*sh=x+k+(len>>1),*fh=x+k,t;// these are heavily used below, that's why
                                                                        // registering them to processor's register
            for(register int j=0;j<nx2;j+=len){
                //we have to transform values at j+k & j+len/2 + k
                // fh is first half, sh is second half
                // fh[j] represents x[j+k], sh[j] represents x[j+len/2+k]
                sh[j]=(fh[j]-(t=(ll)sh[j]*W%mod)<0)?(fh[j]-t+mod):(fh[j]-t);
                fh[j]=(fh[j]+t-mod>=0)?(fh[j]+t-mod):(fh[j]+t);
            }
        }
    }
    if(!inv) return;
    ll invnx2=powm(nx2,mod-2);// if inv is 1 we have to divide by nx2 finally
    for(int i=0;i<nx2;i++) x[i]=x[i]*invnx2%mod;
}
struct poly{

    vector<int> ps;
    inline int ls() {return ps.size()-1;}//point to last element
    inline int& operator [] (int x) {return ps[x];} //ps.at(x)
    inline void resi(int x) {ps.resize(x+1);}
    inline void dbg(){//for debugging purpose, printing polynomial
        bool fi=0;
        for(int i=ls();i>=0;i--){
            ps[i]=(ps[i]%mod+mod)%mod;
            if(!ps[i]) continue;
            if(ps[i]>mod/2) ps[i]-=mod;
            if(fi){
                if(i==0) printf("%+d",ps[i]);
                else if(ps[i]==1) printf("+");
                else if(ps[i]==-1) printf("-");
                else printf("%+d",ps[i]);
            }else{
                if(i==0) printf("%d",ps[i]);
                else if(ps[i]==1);
                else if(ps[i]==-1) printf("-");
                else printf("%d",ps[i]);
            }
            if(i>1) printf("x^%d",i);
            else if(i==1) printf("x");
            fi=1;
        }
        if(!fi) printf("0");
        putchar(10);
    }
    inline void reduce(){//reduce size of ps if highes coeffs are 0
        int p=ls()+1;
        while(p&&!ps[p-1]) --p;
        resi(p-1);
    }
};
namespace PolyMul{int acop[SZ],bcop[SZ],ccop[SZ];}
//using namespace so that this memory isn't used out of scope of this namespace
inline poly operator * (poly a,poly b){
    using namespace PolyMul;
    if(a.ls()<180||b.ls()<180){// if size is this small use bruteforce
        poly res;
        res.resi(a.ls()+b.ls());
        int*R=&res[0],*A=&a[0],*B=&b[0];
        for(int i=0;i<=a.ls();i++){//multiply ith coeff of i toall coeffs of b
            register int*h=R+i,j=0; register ll x=A[i];
            for(;j<=b.ls();++j) h[j]=(h[j]+x*(ll)B[j])%mod;
        }
        return res;
    }
    poly c;
    int t=a.ls()+b.ls();
    c.resi(t); fftinit(t+1);
    memset(acop,0,sizeof(int)*nx2);
    memset(bcop,0,sizeof(int)*nx2);
    memset(ccop,0,sizeof(int)*nx2);
    for(int i=a.ls();i>=0;i--) acop[i]=a[i];
    for(int i=b.ls();i>=0;i--) bcop[i]=b[i];
    fft(acop,0); fft(bcop,0);
    for(int i=0;i<nx2;i++) ccop[i]=(ll)acop[i]*bcop[i]%mod;
    fft(ccop,1);
    for(int i=t;i>=0;i--) c[i]=ccop[i];
    c.reduce();
    return c;
}
namespace PolyInv{int acop[SZ],ainv[SZ],tmp[SZ];}
inline void ginv(int t){//get inverse series modulus x^t
    using namespace PolyInv;
    if(t==1) {ainv[0]=powm(acop[0],mod-2); return;}
    ginv((t+1)>>1); fftinit(t+t+3);//we will multiply two polynomials
                                //that can have first t coeffs non-zero
    memset(tmp,0,sizeof(int)*nx2);
    for(int i=t;i<nx2;i++) tmp[i]=ainv[i]=0;
    for(int i=0;i<t;i++) tmp[i]=acop[i];//
    fft(tmp,0); fft(ainv,0);
    for(int i=0;i<nx2;i++) ainv[i]=(2-(ll)tmp[i]*ainv[i])%mod*ainv[i]%mod;
    fft(ainv,1);
    for(int i=t;i<nx2;i++) ainv[i]=0;
}
inline poly inv(poly a){//get inverse series of polynomial a
    using namespace PolyInv;
    poly y; y.resi(a.ls());
    for(int i=a.ls();i>=0;i--) acop[i]=a[i];
    ginv(a.ls()+1);
    for(int i=a.ls();i>=0;i--) y[i]=ainv[i];
    y.reduce();
    return y;
}
inline poly operator + (poly a,poly b){
    poly res; res.resi(max(a.ls(),b.ls()));
    for(int i=a.ls();i>=0;i--) res[i]=a[i];
    for(int i=b.ls();i>=0;i--) (res[i]+=b[i])%=mod;
    return res;
}
inline poly operator - (poly a,poly b){
    poly res; res.resi(max(a.ls(),b.ls()));
    for(int i=a.ls();i>=0;i--) res[i]=a[i];
    for(int i=b.ls();i>=0;i--){
        (res[i]-=b[i])%=mod;
        if(res[i] < 0) res[i] += mod;
    }
    res.reduce();
    return res;
}
inline void div(poly a,poly b,poly& d,poly& r){//return quotient and remainder
    //when a is divided by b 
    int n=a.ls(),m=b.ls();
    if(n<m) {d.resi(0); d[0]=0; r=a; return;}
    fftinit(2*n);
    poly aa=a; reverse(aa.ps.begin(),aa.ps.end());
    poly bb=b; reverse(bb.ps.begin(),bb.ps.end());
    bb.resi(n-m); bb=inv(bb); d=aa*bb; d.resi(n-m);
    reverse(d.ps.begin(),d.ps.end()); r=a-b*d;
    r.reduce();
}
inline poly operator / (poly a,poly b){
    poly d,r; div(a,b,d,r);
    return d;
}
inline poly operator % (poly a,poly b){
    a.reduce(); b.reduce();
    if(a.ls()<b.ls()) return a;
    poly d,r; div(a,b,d,r); 
    return r;
}
inline poly deriv(poly x){//take derivative of polyomial x
	if(x.ls()<0) return x;
    for(int i=1;i<=x.ls();i++) x[i-1]=(ll)x[i]*i%mod;
    x.resi(x.ls()-1); return x;
}
inline poly integr(poly x){//calculate integral with C = 0
    x.reduce();
    if(x.ls() < 0) return x;
    x.resi(x.ls()+1);
    for(int i = x.ls()+1; i>0; i--) x[i] = (ll)x[i-1]*powm(i,mod-2)%mod;
    x[0] = 0;return x; 
}
inline ll eval(poly& a,ll x){// evaluate polynomial a at x
    ll ans=0;
    for(int i=a.ls();i>=0;i--){
        ans=(ans*x+a[i])%mod;
    }
    return ans;
}
poly st[SZ];//segtree of polynomials
inline void fill_st(int m,int* x,int id){
    if(m==1){
        st[id].resi(1);
        st[id][1]=1;
        st[id][0]=(-(*x)); 
        return;
    }
    int hf=m>>1; fill_st(hf,x,id*2); fill_st(m-hf,x+hf,id*2+1);
    st[id]=st[id*2]*st[id*2+1];
}
namespace PolyGetv{int xs[SZ],anss[SZ];}
inline void get_vals(poly f,int m,int* x,int* ans,int id){
    if(f.ls()<=400){
        int c=f.ls(),*F=&f.ps[0];
        for(int i=0;i<m;i++){
            register ll t=0; register int v=x[i];
            for(register int j=c;~j;--j){//all bits set in -1
                t=(t*v+F[j])%mod;
            }
            ans[i]=t;
        }
        return;
    }
    int hf=m>>1;
    get_vals(f%st[id*2],hf,x,ans,id*2);
    get_vals(f%st[id*2+1],m-hf,x+hf,ans+hf,id*2+1);
}
inline vector<int> getv(poly a,vector<int> x){
    using namespace PolyGetv; a.reduce();
    if(!x.size()) return vector<int>();
    int m=x.size();
    for(int i=0;i<m;i++) xs[i]=x[i];
    fill_st(m,xs,1);
    get_vals(a%st[1],m,xs,anss,1);
    vector<int> ans; ans.resize(m);
    for(int i=0;i<m;i++) ans[i]=anss[i];
    return ans;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>_NTTnew--</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
