<snippet>
	<content><![CDATA[
struct item {
	ll n;
	item(int x = 0): n(x) {}
	item operator+(const item& oth) { //operation to merge
		item r;//default is done for sum
		r.n = n + oth.n;//must be a associative function
		return r;
	}
	item operator*(const int& x) {
		return item(n * x);
	}
	bool operator==(const item& oth) {
		return n == oth.n;
	}
};

template<class node>
struct segtree {
	int n, h;
	vector<node> st;
	vector<node> lazy;
	void init(int _n = 0) { //give some default value value if required
		n = _n;
		h = sizeof(int) * 8 - __builtin_clz(n);
		st.assign(2 * n, node());
		lazy.assign(n, node());
	}

	void build(vector<int> &a) {
		init(a.size());
		for (int i = n; i < 2 * n; i++)
			st[i] = a[i - n];
		for (int i = n - 1; i > 0; i--)
			st[i] = st[i << 1] + st[i << 1 | 1];
	}
	//change vector to int* if required in both build
	void apply(int p, node val, int c) {
		st[p] = st[p] + val * c;
		if (p < n) lazy[p] = lazy[p] + val;
	}

	void calc(int i, int c) { //calculate st[i] using lazy and st
		st[i] = st[i << 1] + st[i << 1 | 1] + lazy[i] * c;
	}

	void push_up(int l, int r) { // push_up [l,r]
		int c;
		for (c = 2; l > 1; c <<= 1) {
			l >>= 1, r >>= 1;
			for (int i = r; i >= l; --i) calc(i, c);
		}
	}

	void push_down(int l, int r) { // push_down [l,r]
		int he = h;
		for (; he > 0; --he) {
			for (int i = l >> he; i <= r >> he; ++i)
				if (!(lazy[i] == node())) {
					apply(i << 1, lazy[i]);
					apply(i << 1 | 1, lazy[i]);
					lazy[i] = node();
				}
		}
	}

	void set(int i, int x) {
		i += n;
		push_down(i, i);
		for (st[i += n] = x; i >>= 1; )
			st[i] = st[i << 1] + st[i << 1 | 1];
	}

	void add(int l, int r, int v) {
		if (r < l || r >= n || l < 0) return;
		l += n, r += n + 1;
		int _l = l, _r = r-1;
		node val(v);
		for (int c = 1; l < r; l >>= 1, r >>= 1, c <<= 1) {
			if (l & 1) apply(l++, val, c);
			if (r & 1) apply(--r, val, c);
		}
		push_up(_l,_l), push_up(_r,_r);
	}
	node query(int l, int r) {// [l, r]
		l += n, r += n + 1;
		push_down(l, l); push_down(r - 1, r - 1);
		node anl, anr;
		for (; l < r; l >>= 1, r >>= 1) {
			if (l & 1) anl = anl + st[l++]; //if l is right child then it's parent is not included
			if (r & 1) anr = st[--r] + anr; // if r is right child then r-1 is left child and same thing
			//parent is not included
		}
		return anl + anr;
	}
};
typedef segtree<item> segm;
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>_lazy_iterative--</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
